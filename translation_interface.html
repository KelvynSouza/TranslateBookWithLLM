<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Translating Books With LLMs</title>
    <style>
        /* ... (Styles CSS inchang√©s) ... */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; color: #1f2937; padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 40px; }
        .header h1 { font-size: 48px; margin-bottom: 10px; }
        .main-card { background: white; border-radius: 20px; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); overflow: hidden; }
        .card-header { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; padding: 30px; }
        .card-body { padding: 30px; }
        .config-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .form-group { display: flex; flex-direction: column; }
        .form-group label { font-weight: 600; margin-bottom: 8px; color: #374151; }
        .form-control { padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 16px; transition: border-color 0.3s; }
        .form-control:focus { outline: none; border-color: #6366f1; }
        .file-upload { margin: 30px 0; padding: 60px; border: 3px dashed #cbd5e1; border-radius: 15px; text-align: center; background: #f9fafb; cursor: pointer; transition: all 0.3s; }
        .file-upload:hover { border-color: #6366f1; background: #f0f0ff; }
        .file-upload.dragging { border-color: #6366f1; background: #e0e7ff; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s; display: inline-flex; align-items: center; gap: 8px; }
        .btn-primary { background: linear-gradient(135deg, #6366f1, #4f46e5); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(99,102,241,0.3); }
        .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn-danger { background-color: #dc3545; color: white; }
        .btn-danger:hover { background-color: #c82333; }
        .btn-danger:disabled { background-color: #dc3545; opacity: 0.6; cursor: not-allowed; }
        .progress-section { margin-top: 30px; padding: 30px; background: #f9fafb; border-radius: 15px; border: 1px solid #e5e7eb; }
        .progress-bar-container { height: 30px; background: #e5e7eb; border-radius: 15px; overflow: hidden; margin: 20px 0; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600;}
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat-card { padding: 20px; background: white; border-radius: 10px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .stat-card h3 { font-size: 32px; color: #6366f1; margin-bottom: 5px; }
        .log-container { max-height: 200px; overflow-y: auto; background: #1f2937; color: #10b981; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 14px; margin-top: 15px; }
        .output-section { margin-top: 30px; padding: 30px; background: #f9fafb; border-radius: 15px; border: 1px solid #e5e7eb; }
        .output-preview { margin-top: 15px; padding: 15px; background: white; border: 1px solid #e5e7eb; border-radius: 8px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; }
        .advanced-toggle { margin: 20px 0; padding: 15px; background: #f3f4f6; border-radius: 8px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .advanced-settings { margin-top: 15px; padding: 20px; background: #fafafa; border-radius: 8px; border: 1px solid #e5e7eb; }
        .hidden { display: none !important; }
        .message { padding: 15px; border-radius: 8px; margin: 15px 0; }
        .error { background: #fee; border: 1px solid #fcc; color: #c00; }
        .success { background: #efe; border: 1px solid #cfc; color: #060; }
        .info { background: #e6f3ff; border: 1px solid #b3d9ff; color: #0066cc; }
        #fileListContainer { margin-top: 10px; max-height: 150px; overflow-y: auto; background: #f9fafb; padding: 10px; border-radius: 8px; border: 1px solid #e5e7eb; }
        #fileListContainer li { list-style-type: none; padding: 5px; border-bottom: 1px solid #eee; }
        #fileListContainer li:last-child { border-bottom: none; }
        .file-status { font-style: italic; color: #555; font-size: 0.9em; margin-left: 10px; }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê Translating Books With LLMs</h1>
            <p>Translate documents with local language models</p>
        </div>

        <div class="main-card">
            <div class="card-header">
                <h2>‚öôÔ∏è Translation Configuration</h2>
            </div>

            <div class="card-body">
                <div class="config-grid">
                    <div class="form-group">
                        <label>Ollama API Endpoint</label>
                        <input type="text" class="form-control" id="apiEndpoint" value="http://localhost:11434/api/generate">
                    </div>

                    <div class="form-group">
                        <label>LLM Model</label>
                        <div style="display: flex; gap: 10px;">
                            <select class="form-control" id="model" style="flex: 1;">
                                <option value="">Loading models...</option>
                            </select>
                            <button class="btn btn-secondary" onclick="loadAvailableModels()" title="Refresh model list">üîÑ</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Source Language</label>
                        <select class="form-control" id="sourceLang" onchange="checkCustomSourceLanguage(this)">
                            <option value="English">English</option>
                            <option value="Chinese">Chinese</option>
                            <option value="Spanish">Spanish</option>
                            <option value="French">French</option>
                            <option value="German">German</option>
                            <option value="Italian">Italian</option>
                            <option value="Portuguese">Portuguese</option>
                            <option value="Hindi">Hindi</option>
                            <option value="Arabic">Arabic</option>
                            <option value="Bengali">Bengali</option>
                            <option value="Russian">Russian</option>
                            <option value="Urdu">Urdu</option>
                            <option value="Other">Other (Specify)</option>
                        </select>
                        <input type="text" class="form-control" id="customSourceLang" placeholder="Enter custom source language" style="margin-top: 10px; display: none;">
                    </div>

                    <div class="form-group">
                        <label>Target Language</label>
                        <select class="form-control" id="targetLang" onchange="checkCustomTargetLanguage(this)">
                            <option value="French">French</option>
                            <option value="English">English</option>
                            <option value="Chinese">Chinese</option>
                            <option value="Spanish">Spanish</option>
                            <option value="German">German</option>
                            <option value="Italian">Italian</option>
                            <option value="Portuguese">Portuguese</option>
                            <option value="Hindi">Hindi</option>
                            <option value="Arabic">Arabic</option>
                            <option value="Bengali">Bengali</option>
                            <option value="Russian">Russian</option>
                            <option value="Urdu">Urdu</option>
                            <option value="Other">Other (Specify)</option>
                        </select>
                        <input type="text" class="form-control" id="customTargetLang" placeholder="Enter custom target language (e.g., Portuguese)" style="margin-top: 10px; display: none;">
                    </div>
                     <div class="form-group">
                        <label>Output Filename Pattern</label>
                        <input type="text" class="form-control" id="outputFilenamePattern" value="translated_{originalName}.txt" title="Use {originalName} as placeholder for original filename without extension.">
                        <small>Example: `translated_{originalName}_to_FR.txt`</small>
                    </div>
                </div>

                <div class="advanced-toggle" onclick="toggleAdvanced()">
                    <span>üîß Advanced Settings</span>
                    <span id="advancedIcon">‚ñº</span>
                </div>

                <div id="advancedSettings" class="advanced-settings hidden">
                    <div class="config-grid">
                        <div class="form-group">
                            <label>Chunk Size (lines)</label>
                            <input type="number" class="form-control" id="chunkSize" value="25" min="5" max="200">
                        </div>
                        <div class="form-group">
                            <label>Request Timeout (sec)</label>
                            <input type="number" class="form-control" id="timeout" value="180" min="30" max="600">
                        </div>
                        <div class="form-group">
                            <label>Context Window (tokens)</label>
                            <input type="number" class="form-control" id="contextWindow" value="4096" min="1024" max="32768">
                        </div>
                        <div class="form-group">
                            <label>Max Retries per Chunk</label>
                            <input type="number" class="form-control" id="maxAttempts" value="2" min="1" max="5">
                        </div>
                         <div class="form-group">
                            <label>Retry Delay (sec)</label>
                            <input type="number" class="form-control" id="retryDelay" value="2" min="1" max="60">
                        </div>
                    </div>
                </div>

                <div class="file-upload" id="fileUpload" onclick="document.getElementById('fileInput').click()">
                    <h3>üìÅ Drag & Drop your .txt files here</h3>
                    <p>or click to select</p>
                    <input type="file" id="fileInput" accept=".txt" style="display: none;" onchange="handleFileSelect(event)" multiple> </div>

                <div id="fileInfo" class="hidden" style="margin-bottom: 20px;">
                    <h4>Selected Files:</h4>
                    <ul id="fileListContainer"></ul> <button class="btn" onclick="resetFiles()" style="background: #e5e7eb; color: #374151; margin-top:10px;">‚ùå Clear All Files</button>
                </div>


                <div id="messages"></div>

                <div style="text-align: center; margin-top: 30px; display: flex; justify-content: center; gap: 15px;">
                    <button class="btn btn-primary" id="translateBtn" onclick="startBatchTranslation()" disabled> ‚ñ∂Ô∏è Start Translation Batch
                    </button>
                    <button class="btn btn-danger hidden" id="interruptBtn" onclick="interruptCurrentTranslation()"> ‚èπÔ∏è Interrupt Current & Stop Batch
                    </button>
                </div>

                <div id="progressSection" class="progress-section hidden">
                    <h3 id="currentFileProgressTitle">üìä Translation Progress</h3>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar" style="width: 0%">0%</div>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card"><h3 id="totalChunks">0</h3><p>Total Chunks</p></div>
                        <div class="stat-card"><h3 id="completedChunks">0</h3><p>Completed</p></div>
                        <div class="stat-card"><h3 id="failedChunks">0</h3><p>Failed</p></div>
                        <div class="stat-card"><h3 id="elapsedTime">0s</h3><p>Time Elapsed</p></div>
                    </div>
                    <h4>üíª Activity Log (Current File)</h4>
                    <div class="log-container" id="logContainer"></div>
                </div>

                <div id="outputSection" class="output-section hidden">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h3 id="outputTitle">üìÑ Translation Result</h3>
                        <button class="btn btn-primary" id="downloadBtn" onclick="downloadLastTranslation()" disabled> ‚¨áÔ∏è Download Last File
                        </button>
                    </div>
                    <div class="output-preview" id="outputPreview"></div>
                    <p style="margin-top: 15px; color: #6b7280; font-size: 14px;">
                        ‚ÑπÔ∏è Preview limited to the first 1000 characters. Full text saved to server.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // MODIFIED: Variables to handle multiple files and batch processing
        let filesToProcess = []; // Array of file objects {name, content, status, outputFilename, translationId, result}
        let translationQueue = [];
        let currentProcessingJob = null; // { fileRef, translationId }
        let isBatchActive = false;
        let lastCompletedJobData = null; // To store data for the download button

        const API_BASE_URL = `${window.location.protocol}//${window.location.hostname}:5000`;
        const socket = io(API_BASE_URL);
        
        socket.on('connect', () => { 
            console.log('WebSocket connected to:', API_BASE_URL); 
            addLog('‚úÖ WebSocket connection to server established.');
        });
        socket.on('disconnect', () => { 
            console.log('WebSocket disconnected.'); 
            addLog('‚ùå WebSocket connection lost.'); 
            if (isBatchActive && currentProcessingJob) {
                showMessage('Connection lost. Batch paused. Reconnect to resume or reset.', 'error');
            }
        });
        
        socket.on('translation_update', (data) => {
            if (currentProcessingJob && data.translation_id === currentProcessingJob.translationId) {
                handleTranslationUpdate(data);
            } else {
                // Log for other updates if necessary, or ignore if not relevant to current UI focus
                console.log("Received update for a different/old job:", data.translation_id);
            }
        });

        function updateFileStatusInList(fileName, newStatus, translationId = null) {
            const fileListItem = document.querySelector(`#fileListContainer li[data-filename="${fileName}"] .file-status`);
            if (fileListItem) {
                fileListItem.textContent = `(${newStatus})`;
            }
            const fileObj = filesToProcess.find(f => f.name === fileName);
            if (fileObj) {
                fileObj.status = newStatus;
                if (translationId) fileObj.translationId = translationId;
            }
        }
        
        function finishCurrentFileTranslationUI(statusMessage, messageType, resultData) {
            if (!currentProcessingJob) return;

            const currentFile = currentProcessingJob.fileRef;
            currentFile.status = resultData.status || 'unknown_error'; // Update status in main list
            currentFile.result = resultData.result; // Store result with file object

            if (resultData && resultData.result) {
                translatedContentFromServer = resultData.result; // Used by existing preview logic
                document.getElementById('outputPreview').textContent = 
                    (translatedContentFromServer || "").substring(0, 1000) + 
                    ((translatedContentFromServer || "").length > 1000 ? '...' : '');
                document.getElementById('outputSection').classList.remove('hidden');
                document.getElementById('outputTitle').textContent = `üìÑ Translation Result for ${currentFile.name}`;
                
                lastCompletedJobData = { // Store for potential download
                    translationId: currentProcessingJob.translationId,
                    outputFilename: currentFile.outputFilename, // Use the determined output filename
                    status: resultData.status
                };
                document.getElementById('downloadBtn').disabled = !(lastCompletedJobData.outputFilename && (lastCompletedJobData.status === 'completed' || lastCompletedJobData.status === 'interrupted'));

            } else {
                 document.getElementById('downloadBtn').disabled = true;
            }

            showMessage(statusMessage, messageType); // Show message for the current file
            updateFileStatusInList(currentFile.name, resultData.status === 'completed' ? 'Completed' : (resultData.status === 'interrupted' ? 'Interrupted' : 'Error'));

            // Reset UI elements for *current file's* translation, ready for next or completion
            // document.getElementById('interruptBtn').classList.add('hidden'); // Interrupt handled by batch logic

            // Process next file in queue
            currentProcessingJob = null; // Clear current job
            processNextFileInQueue(); 
        }

        function handleTranslationUpdate(data) {
            if (!currentProcessingJob || data.translation_id !== currentProcessingJob.translationId) return;

            const currentFile = currentProcessingJob.fileRef;

            if (data.log) addLog(`[${currentFile.name}] ${data.log}`);
            if (data.progress !== undefined) updateProgress(data.progress);
            
            if (data.stats) {
                document.getElementById('totalChunks').textContent = data.stats.total_chunks || '0';
                document.getElementById('completedChunks').textContent = data.stats.completed_chunks || '0';
                document.getElementById('failedChunks').textContent = data.stats.failed_chunks || '0';
                if (data.stats.elapsed_time !== undefined) {
                    document.getElementById('elapsedTime').textContent = data.stats.elapsed_time.toFixed(1) + 's';
                }
            }
            
            if (data.status === 'completed') {
                finishCurrentFileTranslationUI(`‚úÖ ${currentFile.name}: Translation completed!`, 'success', data);
            } else if (data.status === 'interrupted') {
                finishCurrentFileTranslationUI(`‚ÑπÔ∏è ${currentFile.name}: Translation interrupted.`, 'info', data);
            } else if (data.status === 'error') {
                finishCurrentFileTranslationUI(`‚ùå ${currentFile.name}: Error - ${data.error || 'Unknown error.'}`, 'error', data);
            } else if (data.status === 'running') {
                 // This is expected when a file starts processing
                 document.getElementById('progressSection').classList.remove('hidden');
                 document.getElementById('currentFileProgressTitle').textContent = `üìä Translating: ${currentFile.name}`;
                 showMessage(`Translation in progress for ${currentFile.name}...`, 'info');
                 updateFileStatusInList(currentFile.name, 'Processing');
            }
        }
        
        window.addEventListener('load', async () => {
            try {
                const response = await fetch(`${API_BASE_URL}/api/health`);
                if (!response.ok) throw new Error('Server health check failed');
                addLog('Server health check OK.');
                loadAvailableModels();
                const configResponse = await fetch(`${API_BASE_URL}/api/config`);
                if (configResponse.ok) {
                    const defaultConfig = await configResponse.json();
                    document.getElementById('apiEndpoint').value = defaultConfig.api_endpoint || 'http://localhost:11434/api/generate';
                    document.getElementById('chunkSize').value = defaultConfig.chunk_size || 25;
                    document.getElementById('timeout').value = defaultConfig.timeout || 180;
                    document.getElementById('contextWindow').value = defaultConfig.context_window || 4096;
                    document.getElementById('maxAttempts').value = defaultConfig.max_attempts || 2;
                    document.getElementById('retryDelay').value = defaultConfig.retry_delay || 2;
                }
            } catch (error) {
                showMessage(`‚ö†Ô∏è Server unavailable at ${API_BASE_URL}. Ensure Python server is running. ${error.message}`, 'error');
                addLog(`‚ùå Failed to connect to server or load config: ${error.message}`);
            }
        });
        
        async function loadAvailableModels() {
            // ... (Function largely unchanged, logs still global) ...
            const modelSelect = document.getElementById('model');
            modelSelect.innerHTML = '<option value="">Loading models...</option>';
            try {
                const currentApiEp = document.getElementById('apiEndpoint').value;
                const response = await fetch(`${API_BASE_URL}/api/models?api_endpoint=${encodeURIComponent(currentApiEp)}`);
                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.error || `HTTP error ${response.status}`);
                }
                const data = await response.json();
                modelSelect.innerHTML = '';
                
                if (data.models && data.models.length > 0) {
                    data.models.forEach(modelName => {
                        const option = document.createElement('option');
                        option.value = modelName; option.textContent = modelName;
                        if (modelName === data.default) option.selected = true;
                        modelSelect.appendChild(option);
                    });
                    addLog(`‚úÖ ${data.count} LLM model(s) loaded. Default: ${data.default}`);
                    if (data.default && !data.models.includes(data.default)) {
                        showMessage(`‚ÑπÔ∏è Default model '${data.default}' (from server) not found. Using '${data.models[0]}'.`, 'info');
                    }
                } else {
                    const errorMessage = data.error || (currentApiEp.includes('localhost') || currentApiEp.includes('127.0.0.1') ? 
                                        '‚ö†Ô∏è No LLM models found. Ensure Ollama is running, accessible at the specified endpoint, and models are installed (e.g., ollama pull mistral).' :
                                        '‚ö†Ô∏è No LLM models found. Ensure Ollama is accessible at the specified endpoint and models are installed.');
                    showMessage(errorMessage, 'error');
                    modelSelect.innerHTML = '<option value="">No models available</option>';
                }
            } catch (error) {
                showMessage(`‚ùå Error fetching models: ${error.message}`, 'error');
                addLog(`‚ùå Failed to retrieve model list: ${error.message}`);
                modelSelect.innerHTML = '<option value="">Error loading models</option>';
            }
        }

        const fileUploadArea = document.getElementById('fileUpload');
        fileUploadArea.addEventListener('dragover', (e) => { e.preventDefault(); fileUploadArea.classList.add('dragging'); });
        fileUploadArea.addEventListener('dragleave', () => fileUploadArea.classList.remove('dragging'));
        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault(); fileUploadArea.classList.remove('dragging');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                Array.from(files).forEach(file => {
                    if (file.type === 'text/plain') addFileToList(file);
                    else showMessage(`File '${file.name}' is not a .txt file and was skipped.`, 'error');
                });
                updateFileDisplay();
            }
        });

        function toggleAdvanced() { /* ... (Unchanged) ... */ 
            const settings = document.getElementById('advancedSettings');
            document.getElementById('advancedIcon').textContent = settings.classList.toggle('hidden') ? '‚ñº' : '‚ñ≤';
        }
        function checkCustomSourceLanguage(selectElement) { /* ... (Unchanged) ... */ 
            const customLangInput = document.getElementById('customSourceLang');
            customLangInput.style.display = (selectElement.value === 'Other') ? 'block' : 'none';
            if (selectElement.value === 'Other') customLangInput.focus();
        }
        function checkCustomTargetLanguage(selectElement) { /* ... (Unchanged) ... */ 
            const customLangInput = document.getElementById('customTargetLang');
            customLangInput.style.display = (selectElement.value === 'Other') ? 'block' : 'none';
            if (selectElement.value === 'Other') customLangInput.focus();
        }

        // MODIFIED: Handle multiple files
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                Array.from(files).forEach(file => {
                    if (file.type === 'text/plain') addFileToList(file);
                    else showMessage(`File '${file.name}' is not a .txt file and was skipped.`, 'error');
                });
                updateFileDisplay();
            }
             document.getElementById('fileInput').value = ''; // Reset file input to allow re-selection of same file if cleared
        }
        
        function addFileToList(file) {
            if (filesToProcess.find(f => f.name === file.name)) {
                showMessage(`File '${file.name}' is already in the list.`, 'info');
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const originalNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
                const outputPattern = document.getElementById('outputFilenamePattern').value || "translated_{originalName}.txt";
                const outputFilename = outputPattern.replace("{originalName}", originalNameWithoutExt);

                filesToProcess.push({
                    name: file.name,
                    content: e.target.result,
                    status: 'Queued',
                    outputFilename: outputFilename,
                    size: file.size,
                    translationId: null,
                    result: null
                });
                updateFileDisplay(); // Update display after each file is read
            };
            reader.readAsText(file);
        }

        function updateFileDisplay() {
            const fileListContainer = document.getElementById('fileListContainer');
            fileListContainer.innerHTML = ''; // Clear current list

            if (filesToProcess.length > 0) {
                filesToProcess.forEach(file => {
                    const li = document.createElement('li');
                    li.setAttribute('data-filename', file.name); // For easier selection later
                    li.textContent = `${file.name} (${(file.size / 1024).toFixed(2)} KB) `;
                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'file-status';
                    statusSpan.textContent = `(${file.status})`;
                    li.appendChild(statusSpan);
                    fileListContainer.appendChild(li);
                });
                document.getElementById('fileInfo').classList.remove('hidden');
                document.getElementById('translateBtn').disabled = isBatchActive; // Disable if batch is active, enable otherwise
            } else {
                document.getElementById('fileInfo').classList.add('hidden');
                document.getElementById('translateBtn').disabled = true;
            }
        }

        // MODIFIED: Reset for multiple files
        function resetFiles() {
            filesToProcess = [];
            translationQueue = [];
            currentProcessingJob = null;
            isBatchActive = false;
            lastCompletedJobData = null;

            document.getElementById('fileInput').value = ''; // Clear the file input
            updateFileDisplay(); // Will hide fileInfo and disable translateBtn

            document.getElementById('progressSection').classList.add('hidden');
            document.getElementById('outputSection').classList.add('hidden');
            document.getElementById('logContainer').innerHTML = '';
            document.getElementById('translateBtn').innerHTML = '‚ñ∂Ô∏è Start Translation Batch';
            document.getElementById('translateBtn').disabled = true; // Should be disabled by updateFileDisplay
            document.getElementById('interruptBtn').classList.add('hidden');
            document.getElementById('interruptBtn').disabled = false;
            document.getElementById('interruptBtn').innerHTML = '‚èπÔ∏è Interrupt Current & Stop Batch';
            
            document.getElementById('customSourceLang').style.display = 'none';
            document.getElementById('customTargetLang').style.display = 'none';
            document.getElementById('sourceLang').selectedIndex = 0;
            document.getElementById('targetLang').selectedIndex = 0;
            updateProgress(0);
            showMessage('', ''); // Clear messages
            addLog("Form and file list reset.");
        }

        function showMessage(text, type) { /* ... (Unchanged) ... */ 
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = text ? `<div class="message ${type}">${text}</div>` : '';
        }
        function addLog(message) { /* ... (Unchanged, but logs now might be prefixed) ... */ 
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}\n`; // Consider prefixing with current file name if currentProcessingJob is set
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function earlyValidationFail(message) {
            showMessage(message, 'error');
            isBatchActive = false; // Ensure batch is not considered active
            document.getElementById('translateBtn').disabled = filesToProcess.length === 0;
            document.getElementById('translateBtn').innerHTML = '‚ñ∂Ô∏è Start Translation Batch';
            document.getElementById('interruptBtn').classList.add('hidden');
            return false;
        }

        // MODIFIED: Start batch translation
        async function startBatchTranslation() {
            if (isBatchActive || filesToProcess.length === 0) return;

            // Basic validation before starting the whole batch
            let sourceLanguageVal = document.getElementById('sourceLang').value;
            if (sourceLanguageVal === 'Other') {
                sourceLanguageVal = document.getElementById('customSourceLang').value.trim();
                if (!sourceLanguageVal) return earlyValidationFail('Please specify the custom source language for the batch.');
            }
            let targetLanguageVal = document.getElementById('targetLang').value;
            if (targetLanguageVal === 'Other') {
                targetLanguageVal = document.getElementById('customTargetLang').value.trim();
                if (!targetLanguageVal) return earlyValidationFail('Please specify the custom target language for the batch.');
            }
            const selectedModel = document.getElementById('model').value;
            if (!selectedModel) return earlyValidationFail('Please select an LLM model for the batch.');
            const ollamaApiEndpoint = document.getElementById('apiEndpoint').value.trim();
            if (!ollamaApiEndpoint) return earlyValidationFail('Ollama API Endpoint cannot be empty for the batch.');

            isBatchActive = true;
            translationQueue = [...filesToProcess]; // Copy files to a processing queue
            
            document.getElementById('translateBtn').disabled = true;
            document.getElementById('translateBtn').innerHTML = '‚è≥ Batch in Progress...';
            document.getElementById('interruptBtn').classList.remove('hidden');
            document.getElementById('interruptBtn').disabled = false;
            
            document.getElementById('outputSection').classList.add('hidden'); // Hide previous output
            document.getElementById('logContainer').innerHTML = ''; // Clear logs for the new batch (or new file)

            addLog(`üöÄ Batch translation started for ${translationQueue.length} file(s).`);
            showMessage(`Batch of ${translationQueue.length} file(s) initiated.`, 'info');
            
            processNextFileInQueue();
        }

        async function processNextFileInQueue() {
            if (currentProcessingJob) return; // Already processing one

            if (translationQueue.length === 0) {
                isBatchActive = false;
                document.getElementById('translateBtn').disabled = filesToProcess.length === 0; // Re-enable if new files can be added
                document.getElementById('translateBtn').innerHTML = '‚ñ∂Ô∏è Start Translation Batch';
                document.getElementById('interruptBtn').classList.add('hidden');
                showMessage('‚úÖ Batch translation completed for all files!', 'success');
                addLog('üèÅ All files in the batch have been processed.');
                // Progress section can be hidden or show "Batch complete"
                // document.getElementById('progressSection').classList.add('hidden'); 
                document.getElementById('currentFileProgressTitle').textContent = `üìä Batch Completed`;
                return;
            }

            const fileToTranslate = translationQueue.shift(); // Get next file from queue

            // Reset UI for the new file's progress
            updateProgress(0);
            ['totalChunks', 'completedChunks', 'failedChunks'].forEach(id => document.getElementById(id).textContent = '0');
            document.getElementById('elapsedTime').textContent = '0s';
            document.getElementById('logContainer').innerHTML = ''; // Clear logs for the new file
            document.getElementById('outputSection').classList.add('hidden'); // Hide previous output
             document.getElementById('downloadBtn').disabled = true;


            document.getElementById('currentFileProgressTitle').textContent = `üìä Translating: ${fileToTranslate.name}`;
            document.getElementById('progressSection').classList.remove('hidden');
            addLog(`‚ñ∂Ô∏è Starting translation for: ${fileToTranslate.name}`);
            updateFileStatusInList(fileToTranslate.name, 'Preparing...');

            let sourceLanguageVal = document.getElementById('sourceLang').value;
            if (sourceLanguageVal === 'Other') sourceLanguageVal = document.getElementById('customSourceLang').value.trim();
            let targetLanguageVal = document.getElementById('targetLang').value;
            if (targetLanguageVal === 'Other') targetLanguageVal = document.getElementById('customTargetLang').value.trim();

            const config = {
                text: fileToTranslate.content,
                source_language: sourceLanguageVal,
                target_language: targetLanguageVal,
                model: document.getElementById('model').value,
                api_endpoint: document.getElementById('apiEndpoint').value,
                chunk_size: parseInt(document.getElementById('chunkSize').value),
                timeout: parseInt(document.getElementById('timeout').value),
                context_window: parseInt(document.getElementById('contextWindow').value),
                max_attempts: parseInt(document.getElementById('maxAttempts').value),
                retry_delay: parseInt(document.getElementById('retryDelay').value),
                output_filename: fileToTranslate.outputFilename 
            };

            try {
                const response = await fetch(`${API_BASE_URL}/api/translate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `Server error ${response.status} for ${fileToTranslate.name}.`);
                }
                const data = await response.json();
                currentProcessingJob = { fileRef: fileToTranslate, translationId: data.translation_id };
                fileToTranslate.translationId = data.translation_id; // Store ID with the file object
                updateFileStatusInList(fileToTranslate.name, 'Submitted', data.translation_id);
                // First log/status update will come via WebSocket from server
            } catch (error) {
                addLog(`‚ùå Error initiating translation for ${fileToTranslate.name}: ${error.message}`);
                showMessage(`Error starting ${fileToTranslate.name}: ${error.message}`, 'error');
                updateFileStatusInList(fileToTranslate.name, 'Initiation Error');
                currentProcessingJob = null; // Clear job so next can start
                processNextFileInQueue(); // Try next file
            }
        }
        
        // MODIFIED: Interrupt current file and stop the batch
        async function interruptCurrentTranslation() {
            if (!isBatchActive || !currentProcessingJob) {
                showMessage('No active translation to interrupt.', 'info');
                return;
            }

            const fileToInterrupt = currentProcessingJob.fileRef;
            const tidToInterrupt = currentProcessingJob.translationId;

            document.getElementById('interruptBtn').disabled = true;
            document.getElementById('interruptBtn').innerHTML = '‚è≥ Interrupting...';
            addLog(`üõë User requested interruption for ${fileToInterrupt.name} (ID: ${tidToInterrupt}). This will stop the batch.`);
            
            translationQueue = []; // Clear the rest of the queue

            try {
                const response = await fetch(`${API_BASE_URL}/api/translation/${tidToInterrupt}/interrupt`, { method: 'POST' });
                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.message || `Failed to send interrupt signal for ${fileToInterrupt.name}.`);
                }
                // Message will be updated via WebSocket by server for the current file.
                // The call to processNextFileInQueue() in handleTranslationUpdate will find an empty queue.
                showMessage(`‚ÑπÔ∏è Interruption for ${fileToInterrupt.name} requested. Batch will stop after this file.`, 'info');
            } catch (error) {
                showMessage(`‚ùå Error sending interruption for ${fileToInterrupt.name}: ${error.message}`, 'error');
                // Re-enable interrupt button only if we are sure the job is still somehow active
                // For simplicity, the batch stop is already signaled by clearing the queue.
                // The current job will eventually finish (interrupted or error) and then batch ends.
                 document.getElementById('interruptBtn').disabled = false; // Re-enable if error, as interrupt might not have registered
                 document.getElementById('interruptBtn').innerHTML = '‚èπÔ∏è Interrupt Current & Stop Batch';

            }
        }

        function updateProgress(percent) { /* ... (Unchanged) ... */ 
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percent + '%';
            progressBar.textContent = Math.round(percent) + '%';
        }

        // MODIFIED: Download for the last completed file
        function downloadLastTranslation() {
            if (!lastCompletedJobData || !lastCompletedJobData.translationId) {
                showMessage('No completed translation available for download, or ID missing.', 'error'); return;
            }
            if (lastCompletedJobData.status !== 'completed' && lastCompletedJobData.status !== 'interrupted') {
                 showMessage(`Cannot download file as its status is '${lastCompletedJobData.status}'.`, 'error'); return;
            }
            const downloadUrl = `${API_BASE_URL}/api/download/${lastCompletedJobData.translationId}`;
            addLog(`Initiating download for ${lastCompletedJobData.outputFilename} from: ${downloadUrl}`);
            window.location.href = downloadUrl;
        }

    </script>
</body>
</html>